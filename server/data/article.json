{
	"success": true,
	"data": {
		"abstract": "",
		"thumbnail": "",
		"isTop": false,
		"isPublish": true,
		"isRecommend": true,
		"enableComment": true,
		"views": 2806,
		"flag": 0,
		"likes": [],
		"media": [],
		"tags": [{
			"name": "JavaScript",
			"id": "5a6b00671f9805109c9ffa08"
		}],
		"title": "ES7异步操作-async函数",
		"content": "### 概述\n\nasync函数是Generator函数的语法糖，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await\n\n使用Generator 函数，依次读取两个文件\n\n```js\nlet fs = require('fs')\nlet readFile = function(filename){\n  return new Promise(function(resolve, reject){\n    fs.readFile(filename, function(error, contents){\n      if(error) return reject(error)\n      resolve(contents)\n    })\n  })\n}\n\n// 自定义一个执行器\nfunction run(task) {\n  let iterator = task(); // 生成器函数task的迭代器\n  let result = iterator.next(); // 启动任务\n  function step() { // 递归调用step函数，保持对next()的调用\n    if(!result.done) {\n      let promise = Promise.resolve(result.value);\n      promise.then(function(value){\n        result = iterator.next(value);\n        step();\n      }).catch(function(error){\n        result = iterator.throw(error);\n        step();\n      })\n    }\n  }\n  step(); // 启动处理过程\n}\n\nlet g = function *() {\n  let ret1 = yield readFile('./a.json')\n  let ret2 = yield readFile('./b.json')\n  console.log(ret1.toString(), ret2.toString())\n}\nrun(g)\n```\n使用Async 函数，依次读取两个文件\n\n```js\nlet fs = require('fs')\nlet readFile = function(filename){\n  return new Promise(function(resolve, reject){\n    fs.readFile(filename, function(error, contents){\n      if(error) return reject(error)\n      resolve(contents)\n    })\n  })\n}\n\nlet asyncReadFile = async function() {\n  let ret1 = await readFile('./a.json')\n  let ret2 = await readFile('./b.json')\n  console.log(ret1.toString(), ret2.toString())\n}\nasyncReadFile()\n```\n\nrun()执行器在上一篇文章[Promise和异步编程](https://www.86886.wang/posts/5b38740d8c98760acf25bfab)中已经介绍过了，从调用方式上看，两者确实很相似。Async函数对 Generator 函数的改进，主要体现在以下四点：\n\n#### 1. 内置执行器\n\nGenerator 函数的执行必须靠执行器，就是示例中的run()函数。而Async函数自带执行器，所以Async函数的执行开起来和普通函数一模一样\n\n#### 语义化\n\nasync-await相比星号和yield的语义更加清晰，async表示函数里有异步操作，await表示等待表达式结果\n\n#### 适用性广\n\nasync函数的await命令后面，可以是Promise 对象，也可以是原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）\n\n#### 返回值是Promise\n\nasync函数的返回值是一个Promise，所以可以用then()方法指定下一步操作，而Generator 函数的返回值是 Iterator 对象。\n\n### 多种使用形式\n\nasync 函数有多种使用形式\n\n```js\n// 函数声明\nasync function test(){}\n\n// 函数表达式\nconst test = async function(){}\n\n// 箭头函数\nconst test = async () => {}\n\n// 对象的方法\nlet obj = {\n  async getName(){}\n}\n\n// Class方法\nclass Person() {\n  async getInfo(url) {\n    let response = await fetch(url)\n    return await response.text()\n  }\n}\n```\n\n### 语法\n\nasync函数返回一个Promise对象，所以可以使用then()方法添加回调函数，async函数内部return语句返回的值，会成为then方法回调函数的参数\n\n```js\nasync function getData(url) {\n  let response = await fetch(url)\n  let result = await response.text()\n  return result\n}\n\ngetData('https://86886.wang/api/articles').then(function(result){\n  console.log(result)\n})\n```\n\n示例向一个地址请求数据，请求结束后打印返回的数据\n\n#### Promise 对象的状态变化\n\nasync函数返回的Promise对象，必须要等到await命令后面的Promise对象执行完成，才会发生发生状态改变，除非遇到return语句或者抛出错误。\n\n上面的示例中，必须要等待getData内部的await都执行完，才会执行getData的then()方法\n\n#### awiat命令\n\n通常await命令后面是一个Promsie对象，如果不是会被转换成一个立即resolve的Promsie对象\n\n```js\nasync function test() {\n  return await 'hello' \n}\ntest().then((value) => {\n  console.log(value) // hello\n})\n```\n\nawait后面的'hello'会被转换成Promise对象，并立即resolve\n\nawait命令后面的Promise对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到\n\n```js\nasync function test() {\n  return await Promise.reject('bad request')\n}\ntest().catch((value) => {\n  console.log(value) // bad request\n})\n```\n\nPromise.reject()前面的return可以省略，错误仍然可以被catch接收到。但是如果Promise.resolve()前面的return省略了，then方法是接收不到返回值的\n\nasync函数里，只要有一个awiat语句后的Promsie变成reject，那么整个async函数都会中断执行\n\n```js\nasync function test() {\n  let r1 = await Promise.reject('bad request')\n  let r2 = await Promise.resolve('hello') // 不会执行\n}\n```\n\n如果需要即使异步操作失败也不要中断后面的异步操作，可把await放到try-catch块里\n\n```js\nasync function test() {\n  try{\n    await Promise.reject('bad request')\n  }catch(e){}\n  return await Promise.resolve('hello') // 正常执行\n}\n\ntest().then(v => console.log(v)) // hello\n```\n\n也可以在await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误\n\n```js\nasync function test() {\n  await Promise.reject('bad request').catch(e => console.log(e))\n  return await Promise.resolve('hello') // 正常执行\n}\n\ntest().then(v => console.log(v)) \n// bad request\n// hello\n```\n\n#### 错误处理\n\n如果async函数内部抛出错误，会导致返回的Promise对象变为reject状态，错误对象会被catch()方法接收到\n\n\n```js\nasync function test() {\n  throw new Error('bad request')\n}\n\ntest().then((value) => {\n  console.log(value)\n},(error) => {\n  console.log(error.message) // bad request\n})\n```\n\n```js\nasync function test() {\n  await new Promise(function(resolve, reject){\n    throw new Error('bad request')\n  })\n}\n\ntest().then((value) => {\n  console.log(value)\n},(error) => {\n  console.log(error.message) // bad request\n})\n```\n\n防止出错的方法前面说过了，将其放在try...catch代码块之中\n\n#### 注意事项\n\n1. 由于await命令后面的Promsie对象，运行结果可能是rejected，所以最好把await命令放到try-catch块中\n\n```js\nasync function test(url) {\n  try{\n    await fetch(url)\n  }catch(err){\n    console.log(err)\n  }\n}\n\n// 或者这样\nasync function test(url) {\n  await fetch(url).catch(err => console.log(err))\n}\n```\n\n2. 对于多个await后面的异步操作，如果不存在继发关系，最好让它们并发执行，这样可以减少耗时\n\n```js\n// 继发\nlet ret1 = await getArticles()\nlet ret2 = await getTags()\n\n// 并发\nlet [ret1, ret2] = await Promise.all([getArticles(), getTags()])\n```\n\n3. async函数在forEach循环中可能会出错，可以使用for-of循环\n\n```js\n// 可能出错\nfunction test(db) {\n  let arr = [{}, {}, {}]\n  arr.forEach(async function(item) {\n    await db.post(item)\n  })\n}\n\n// 不会出错\nasync function test(db) {\n  let arr = [{},{},{}]\n  for(let item of arr) {\n    await db.post(item)\n  }\n}\n```\n\n在forEach中可能出错的原因是，所有异步操作都是并发的，而在for-of中所有异步操作是继发的\n\n如果确实需要在循环中，并发执行多个异步操作，可以使用Promise.all()方法解决\n\n```js\nasync function test(db) {\n  let arr = [{}, {}, {}]\n  let promises = arr.map(item => db.post(item))\n  let results = await Promise.all(promises)\n\n  console.log(results)\n}\n```\n\n### 应用\n\n实际开发中，经常遇到一组异步操作，需要按照顺序完成。使用async可以这样做\n\n```js\nasync function getData(urls) {\n  for(const url of urls) {\n    const response = await fetch(url)\n    console.log(await response.rext())\n  }\n}\n\ngetData(['https://86886.wang/api/articles', 'https://86886.wang/api/tags', 'https://86886.wang/api/archives'])\n```\n\n虽然确实是按顺序返回的，但是所有操作都是继发的，这样效率太慢了。下面改一些，让它是并发执行且按顺序返回数据\n\n```js\nasync function getData(urls) {\n  // 并发\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url)\n    return response.text()\n  })\n  // 按顺序返回\n  for(const textPromise of textPromises){\n    console.log(await textPromise)\n  }\n}\n\ngetData(['https://86886.wang/api/articles', 'https://86886.wang/api/tags', 'https://86886.wang/api/archives'])\n```\n\n示例中，map方法中参数是一个async函数，它们可以并发执行请求。而外部的async函数结合for-of循环，可以实现继发的按顺序输出\n",
		"createdAt": "2018-07-01T12:58:49.461Z",
		"updatedAt": "2019-04-25T11:42:33.802Z",
		"extends": [],
		"user": {
			"avatar": "https://www.86886.wang/public/avatar/default.jpg",
			"username": "admin",
			"email": "qq22337383@gmail.com",
			"id": "5a6c79b5ff740253337009f1"
		},
		"category": {
			"name": "JavaScript笔记",
			"isShow": true,
			"id": "5ca96ba6f3e60f574a88408b"
		},
		"id": "5b38d0098c98760acf25bfac"
	}
}